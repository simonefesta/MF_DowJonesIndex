method="lm" , formula=y ~ x, se=FALSE, fullrange=FALSE) +
geom_point(alpha=1, size=1.0, shape=19, aes(color="col_1")) +
scale_x_continuous(name=x_name, breaks=x_breaks, label=x_labs, limits=x_lims) +
scale_y_continuous(name=y_name, breaks=y_breaks, labels=NULL, limits=y_lims,
sec.axis=sec_axis(~., breaks=y_breaks, labels=y_labs)) +
ggtitle(title_content) +
labs(subtitle=subtitle_content, caption=caption_content) +
scale_colour_manual(name="Legend", labels=leg_labs, values=leg_cols, breaks=leg_ord,
guide=guide_legend(override.aes=list(shape=c(19,NA,NA),
linetype=c("blank", "solid", "dashed")))) +
theme(plot.title=element_text(hjust=0.5), plot.subtitle=element_text(hjust=0.5),
axis.text.x=element_text(angle=0, vjust=1),
legend.key.width=unit(1.0,"cm"), legend.position="bottom")
plot(Call_Put_Price_Strike_Pr_2023_04_11_06_16_sp)
#
PutCallPrice_par_lm <- lm(y~0+x)
summary(PutCallPrice_par_lm)
#
# 1/(1+r_f)=c, 1/c=1+r_f, 1/c-1=r_f,
#
r_f <- 1/PutCallPrice_par_lm$coefficients[1]-1
show(r_f)
# 0.007666662
#
Days_to_Mat <- as.vector(difftime("2023-06-16", "2023-04-11"))
show(Days_to_Mat)
# 66
#
r_f_a=(1+r_f)^(365.2425/Days_to_Mat)-1
show(r_f_a)
# 0.04317122
#
label_percent(accuracy = 0.001)(r_f_a)
# 4.317%
#
SPX_Opt_2023_05_18_06_16_df <- read.csv("SPX_Option_Chain_2023_05_18_06_16.csv")
class(SPX_Opt_2023_05_18_06_16_df)
head(SPX_Opt_2023_05_18_06_16_df,10)
tail(SPX_Opt_2023_05_18_06_16_df,10)
#
Call_LastTrDate_df <- data.frame(Call_LastTrDate=as.Date(SPX_Opt_2023_05_18_06_16_df$Call_LastTrTime))
class(Call_LastTrDate_df)
head(Call_LastTrDate_df,20)
nrow(Call_LastTrDate_df)
Call_LastTrDate_tb <- table(Call_LastTrDate_df)
class(Call_LastTrDate_tb)
show(Call_LastTrDate_tb)
#
Put_LastTrDate_df <- data.frame(Put_LastTrDate=as.Date(SPX_Opt_2023_05_18_06_16_df$Put_LastTrTime))
class(Put_LastTrDate_df)
head(Put_LastTrDate_df,20)
nrow(Put_LastTrDate_df)
Put_LastTrDate_tb <- table(Put_LastTrDate_df)
class(Put_LastTrDate_tb)
show(Put_LastTrDate_tb)
#
Call_LastTrDate_2023_05_18_Indx <- SPX_Opt_2023_05_18_06_16_df$Indx[which(Call_LastTrDate_df$Call_LastTrDate=="2023-05-18")]
show(Call_LastTrDate_2023_05_18_Indx)
length(Call_LastTrDate_2023_05_18_Indx)
Put_LastTrDate_2023_05_18_Indx <- SPX_Opt_2023_05_18_06_16_df$Indx[which(Put_LastTrDate_df$Put_LastTrDate=="2023-05-18")]
show(Put_LastTrDate_2023_05_18_Indx)
length(Put_LastTrDate_2023_05_18_Indx)
Call_Put_2023_05_18_Indx <- intersect(Call_LastTrDate_2023_05_18_Indx, Put_LastTrDate_2023_05_18_Indx)
show(Call_Put_2023_05_18_Indx)
length(Call_Put_2023_05_18_Indx)
# 69
#
Call_LastTrDate_2023_05_17_Indx <- SPX_Opt_2023_05_18_06_16_df$Indx[which(Call_LastTrDate_df$Call_LastTrDate=="2023-05-17")]
show(Call_LastTrDate_2023_05_17_Indx)
length(Call_LastTrDate_2023_05_17_Indx)
Put_LastTrDate_2023_05_17_Indx <- SPX_Opt_2023_05_18_06_16_df$Indx[which(Put_LastTrDate_df$Put_LastTrDate=="2023-05-17")]
show(Put_LastTrDate_2023_05_17_Indx)
length(Put_LastTrDate_2023_05_17_Indx)
Call_Put_2023_05_17_Indx <- intersect(Call_LastTrDate_2023_05_17_Indx, Put_LastTrDate_2023_05_17_Indx)
show(Call_Put_2023_05_17_Indx)
length(Call_Put_2023_05_17_Indx)
# 1
#
# Put-Call parity
# P_0 = C_0 - S_0 + K/(1+r_f)
# C_0-P_0 = S_0 - K/(1+r_f)
#
x <- SPX_Opt_2023_05_18_06_16_df$Strike[Call_Put_2023_05_18_Indx]
show(x)
length(x)
y <- SPX_Opt_2023_05_18_06_16_df$Call_LastPr[Call_Put_2023_05_18_Indx]-SPX_Opt_2023_05_18_06_16_df$Put_LastPr[Call_Put_2023_05_18_Indx]
show(y)
length(y)
#
Data_df <- data.frame(x,y)
n <- nrow(Data_df)
title_content <- bquote(atop("University of Roma \"Tor Vergata\" - \u0040 MPSMF 2022-2023",
paste("Scatter Plot of the Call-Put Difference Against the Strike Price")))
subtitle_content <- bquote(paste("Data set size",~~.(n),~~"sample points;    Evaluation Date 2023-05-18;   Maturity Date 2023-06-16"))
caption_content <- "Author: Roberto Monte"
# To obtain the submultiples of the length of the data set as a hint on the number of breaks to use
# library(numbers)
# primeFactors(n)
x_breaks_num <- 23
x_breaks_low <- min(Data_df$x)
x_breaks_up <- max(Data_df$x)
x_binwidth <- floor((x_breaks_up-x_breaks_low)/x_breaks_num)
x_breaks <- seq(from=x_breaks_low, to=x_breaks_up, by=x_binwidth)
if((x_breaks_up-max(x_breaks))>x_binwidth/2){x_breaks <- c(x_breaks,x_breaks_up)}
x_labs <- format(x_breaks, scientific=FALSE)
J <- 0
x_lims <- c(x_breaks_low-J*x_binwidth,x_breaks_up+J*x_binwidth)
x_name <- bquote("strike")
y_breaks_num <- 10
y_max <- max(na.rm(Data_df$y))
y_min <- min(na.rm(Data_df$y))
y_binwidth <- round((y_max-y_min)/y_breaks_num, digits=3)
y_breaks_low <- y_min
y_breaks_up <- y_max
y_breaks <- seq(from=y_breaks_low, to=y_breaks_up, by=y_binwidth)
if((y_breaks_up-max(y_breaks))>y_binwidth/2){y_breaks <- c(y_breaks,y_breaks_up)}
y_labs <- format(y_breaks, scientific=FALSE)
y_name <- bquote("call-put difference")
K <- 1
y_lims <- c((y_breaks_low-K*y_binwidth), (y_breaks_up+K*y_binwidth))
col_1 <- bquote("data set sample points")
col_2 <- bquote("regression line")
col_3 <- bquote("LOESS curve")
leg_labs <- c(col_1, col_2, col_3)
leg_cols <- c("col_1"="blue", "col_2"="green", "col_3"="red")
leg_ord <- c("col_1", "col_2", "col_3")
Call_Put_Strike_Pr_2023_05_18_06_16_sp <- ggplot(Data_df, aes(x=x, y=y)) +
geom_smooth(alpha=1, linewidth=0.8, linetype="dashed", aes(color="col_3"),
method="loess", formula=y ~ x, se=FALSE) +
geom_smooth(alpha=1, linewidth=0.8, linetype="solid", aes(color="col_2"),
method="lm" , formula=y ~ x, se=FALSE, fullrange=TRUE) +
geom_point(alpha=1, size=1.0, shape=19, aes(color="col_1")) +
scale_x_continuous(name=x_name, breaks=x_breaks, label=x_labs, limits=x_lims) +
scale_y_continuous(name=y_name, breaks=y_breaks, labels=NULL, limits=y_lims,
sec.axis=sec_axis(~., breaks=y_breaks, labels=y_labs)) +
ggtitle(title_content) +
labs(subtitle=subtitle_content, caption=caption_content) +
scale_colour_manual(name="Legend", labels=leg_labs, values=leg_cols, breaks=leg_ord,
guide=guide_legend(override.aes=list(shape=c(19,NA,NA),
linetype=c("blank", "solid", "dashed")))) +
theme(plot.title=element_text(hjust=0.5), plot.subtitle=element_text(hjust=0.5),
axis.text.x=element_text(angle=0, vjust=1),
legend.key.width=unit(1.0,"cm"), legend.position="bottom")
plot(Call_Put_Strike_Pr_2023_05_18_06_16_sp)
#
PutCall_par_lm <- lm(y~x)
summary(PutCall_par_lm)
#
S_0 <- PutCall_par_lm$coefficients[1]
show(S_0)
# 4189.735
# SPX Market Price 4,198.05 At close: May 18 :55PM EDT
#
r_f <- -(1/PutCall_par_lm$coefficients[2]+1)
show(r_f)
# 0.00211723
#
Days_to_Mat <- as.vector(difftime("2023-06-16", "2023-05-18"))
show(Days_to_Mat)
# 29
#
r_f_a=(1+r_f)^(365.2425/Days_to_Mat)-1
show(r_f_a)
# 0.02699536
#
label_percent(accuracy = 0.001)(r_f_a)
# 2.700%
#
# Put-Call parity
# P_0 = C_0 - S_0 + K/(1+r_f)
# P_0 - C_0 + S_0 = K/(1+r_f)
#
S_0 <- 4198.05
#
x <- SPX_Opt_2023_05_18_06_16_df$Strike[Call_Put_2023_05_18_Indx]
show(x)
length(x)
y <- SPX_Opt_2023_05_18_06_16_df$Put_LastPr[Call_Put_2023_05_18_Indx]-SPX_Opt_2023_05_18_06_16_df$Call_LastPr[Call_Put_2023_05_18_Indx]+S_0
show(y)
length(y)
#
Data_df <- data.frame(x,y)
n <- nrow(Data_df)
title_content <- bquote(atop("University of Roma \"Tor Vergata\" - \u0040 MPSMF 2022-2023",
paste("Scatter Plot of the Call-Put Difference Adjusted by the Stock Price Against the Strike Price")))
subtitle_content <- bquote(paste("Data set size",~~.(n),~~"sample points;    Evaluation Date 2023-05-18;   Maturity Date 2023-06-16"))
caption_content <- "Author: Roberto Monte"
# To obtain the sub-multiples of the length of the data set as a hint on the number of breaks to use
# library(numbers)
# primeFactors(n)
x_breaks_num <- 13
x_breaks_low <- Data_df$x[1]
x_breaks_up <- Data_df$x[n]
x_binwidth <- floor((x_breaks_up-x_breaks_low)/x_breaks_num)
x_breaks <- seq(from=x_breaks_low, to=x_breaks_up, by=x_binwidth)
if((x_breaks_up-max(x_breaks))>x_binwidth/2){x_breaks <- c(x_breaks,x_breaks_up)}
x_labs <- format(x_breaks, scientific=FALSE)
J <- 0
x_lims <- c(x_breaks_low-J*x_binwidth,x_breaks_up+J*x_binwidth)
x_name <- bquote("strike")
y_breaks_num <- 10
y_max <- max(na.rm(Data_df$y))
y_min <- min(na.rm(Data_df$y))
y_binwidth <- round((y_max-y_min)/y_breaks_num, digits=3)
y_breaks_low <- y_min
y_breaks_up <- y_max
y_breaks <- seq(from=y_breaks_low, to=y_breaks_up, by=y_binwidth)
if((y_breaks_up-max(y_breaks))>y_binwidth/2){y_breaks <- c(y_breaks,y_breaks_up)}
y_labs <- format(y_breaks, scientific=FALSE)
y_name <- bquote("call-put difference")
K <- 1
y_lims <- c((y_breaks_low-K*y_binwidth), (y_breaks_up+K*y_binwidth))
col_1 <- bquote("data set sample points")
col_2 <- bquote("regression line")
col_3 <- bquote("LOESS curve")
leg_labs <- c(col_1, col_2, col_3)
leg_cols <- c("col_1"="blue", "col_2"="green", "col_3"="red")
leg_ord <- c("col_1", "col_2", "col_3")
Call_Put_Price_Strike_Pr_2023_05_18_06_16_sp <- ggplot(Data_df, aes(x=x, y=y)) +
geom_smooth(alpha=1, linewidth=0.8, linetype="dashed", aes(color="col_3"),
method="loess", formula=y ~ x, se=FALSE) +
geom_smooth(alpha=1, linewidth=0.8, linetype="solid", aes(color="col_2"),
method="lm" , formula=y ~ x, se=FALSE, fullrange=TRUE) +
geom_point(alpha=1, size=1.0, shape=19, aes(color="col_1")) +
scale_x_continuous(name=x_name, breaks=x_breaks, label=x_labs, limits=x_lims) +
scale_y_continuous(name=y_name, breaks=y_breaks, labels=NULL, limits=y_lims,
sec.axis=sec_axis(~., breaks=y_breaks, labels=y_labs)) +
ggtitle(title_content) +
labs(subtitle=subtitle_content, caption=caption_content) +
scale_colour_manual(name="Legend", labels=leg_labs, values=leg_cols, breaks=leg_ord,
guide=guide_legend(override.aes=list(shape=c(19,NA,NA),
linetype=c("blank", "solid", "dashed")))) +
theme(plot.title=element_text(hjust=0.5), plot.subtitle=element_text(hjust=0.5),
axis.text.x=element_text(angle=0, vjust=1),
legend.key.width=unit(1.0,"cm"), legend.position="bottom")
plot(Call_Put_Price_Strike_Pr_2023_05_18_06_16_sp)
#
PutCallPrice_par_lm <- lm(y~0+x)
summary(PutCallPrice_par_lm)
#
r_f <- 1/PutCallPrice_par_lm$coefficients[1]-1
show(r_f)
# 8.067738e-05
#
Days_to_Mat <- as.vector(difftime("2023-06-16", "2023-05-18"))
show(Days_to_Mat)
# 29
#
r_f_a=(1+r_f)^(365.2425/Days_to_Mat)-1
show(r_f_a)
# 0.001016572
#
label_percent(accuracy = 0.001)(r_f_a)
# 0.102%
#
##############################################################################################################################
##############################################################################################################################
##############################################################################################################################
# European Options on Standard & Poor 500 (Yahoo Finance - ^SPX)
##############################################################################################################################
# library(quantmod)
SPX_Opt_2023_05_12 <- getOptionChain("^SPX", Exp="2023-05-12", src='yahoo')
ESM24.CME_df <- getSymbols.yahoo("ESM24.CME", from=From, to=To, periodicity="daily",
base.currency="USD",  return.class="data.frame", env = .GlobalEnv,
verbose = FALSE, warning = TRUE, auto.assign = FALSE)
ESM24.CME_df
class(ESM24.CME_df)
head(ESM24.CME_df)
tail(ESM24.CME_df)
# We remove the rows with NA from the data frame *ESM24.CME_df*.
ESM24.CME_df <- na.omit(ESM24.CME_df)
ESM24.CME_df
# We set the row names of the data frame *ESM24.CME_df* to the default values.
rownames(ESM24.CME_df) <- NULL
head(ESM24.CME_df)
tail(ESM24.CME_df)
# We add an Index column to the data frame *ESM24.CME_df*.
ESM24.CME_df <- add_column(.data=ESM24.CME_df, Index=1:nrow(ESM24.CME_df), .before="Date")
ESM24.CME_df
# We add an Index column to the data frame *ESM24.CME_df*.
ESM24.CME_df <- add_column(.data=ESM24.CME_df, Index=1:nrow(ESM24.CME_df), .before=NULL)
ESM24.CME_df
save(ESM24.CME_df, file="ESM24.CME_2022_04_12__2023_04_11_df.RData")
save(ESM24.CME_df, file="ESM24.CME_2022_04_12__2023_04_11_df.RData")
save(ESM24.CME_df, file="ESM24.CME_2022_04_12__2023_04_11_df.RData")
# rm(ESM24.CME_df)
head(ESM24.CME_df)
#
# LOAD
load("ESM24.CME_2022_04_12__2023_04_11_df.RData")
head(ESM24.CME_df)
tail(ESM24.CME_df)
# the adjusted price is the strike price K of the future contract at the end of day and we know that in arbitrage-free
# markets the Spot futures Parity Theorem holds true
# K = S_0(1+r_f)
# from which it follows
# K/S_0 - 1 = r_f
# We download also the spot prices of Standard & Poor 500 Index (^GSCP)
# https://finance.yahoo.com/quote/%5EGSPC?p=%5EGSPC
# see also Standard & Poor 500 Index (^SPX)
# https://it.finance.yahoo.com/quote/%5ESPX/history?period1=1649721600&period2=1681171200&interval=1d&filter=history&frequency=1d&includeAdjustedClose=true
# see also
GSPC_df <- getSymbols.yahoo("^GSPC", from=From, to=To, periodicity="daily",
base.currency="USD",  return.class="data.frame", env = .GlobalEnv,
verbose = FALSE, warning = TRUE, auto.assign = FALSE)
class(GSPC_df)
head(GSPC_df)
tail(GSPC_df)
#
# We add a Date column to the data frame *GSPC_df*.
GSPC_df <- add_column(.data=GSPC_df, Date=as.Date(rownames(GSPC_df), format="%Y-%m-%d"), .before="GSPC.Open")
head(GSPC_df)
tail(GSPC_df)
# We set the row names of the data frame *GSPC_df* to the default values.
rownames(GSPC_df) <- NULL
head(GSPC_df)
tail(GSPC_df)
# We add an Index column to the data frame *ESM24.CME_df*.
GSPC_df <- add_column(.data=GSPC_df, Index=1:nrow(GSPC_df), .before="Date")
head(GSPC_df)
tail(GSPC_df)
# We save, remove, and restore the downloaded file
save(GSPC_df, file="GSPC_2022_04_12__2023_04_11_df.RData")
# rm(GSPC_df)
head(GSPC_df)
#
# LOAD
load("GSPC_2022_04_12__2023_04_11_df.RData")
head(GSPC_df)
tail(GSPC_df)
#
# Note that the numbers of rows in data frames *ESM24.CME_df* and *GSPC_df* are different.
# More precisely, the data frame *ESM24.CME_df* contains one more row than *GSPC_df*.
# Hence, there are rows in *ESM24.CME_df* which are not in *GSPC_df*. The converse also being possible.
# To know what row of *ESM24.CME_df* is not in *GSPC_df* we use the following function
ESM24.CME_add_row <- which(!(ESM24.CME_df$Date %in% GSPC_df$Date))
class(ESM24.CME_add_row)
show(ESM24.CME_add_row)
# 192
#
# The *ESM24.CME_add_row* corresponds to the date
show(ESM24.CME_df$Date[ESM24.CME_add_row])
# "2023-01-16"
#
# Since only one row of *ESM24.CME_df* is not in *GSPC_df*, and *ESM24.CME_df* contains only an additional row,
# all rows in *GSPC_df* must be in *ESM24.CME_df*.
# However, if we check the possibility that some rows of *ESM24.CME_df* are not in *ESM24.CME_df*, we find
GSPC_add_row <- which(!(GSPC_df$Date %in% ESM24.CME_df$Date))
show(GSPC_add_row)
# integer(0)
# which confirms that all rows of *GSPC_df* are in *ESM24.CME_df*.
# Hence, we check the data frames ESM24.CME_df and GSPC_df$Date around the the missed row.
show(ESM24.CME_df[(ESM24.CME_add_row-5):(ESM24.CME_add_row+5),])
show(GSPC_df[(ESM24.CME_add_row-5):(ESM24.CME_add_row+5),])
# the adjusted price is the strike price K of the future contract at the end of day and we know that in arbitrage-free
# markets the Spot futures Parity Theorem holds true
# K = S_0(1+r_f)
# from which it follows
# K/S_0 - 1 = r_f
# We download also the spot prices of Standard & Poor 500 Index (^GSCP)
# https://finance.yahoo.com/quote/%5EGSPC?p=%5EGSPC
# see also Standard & Poor 500 Index (^SPX)
# https://it.finance.yahoo.com/quote/%5ESPX/history?period1=1649721600&period2=1681171200&interval=1d&filter=history&frequency=1d&includeAdjustedClose=true
# see also
GSPC_df <- getSymbols.yahoo("^GSPC", from=From, to=To, periodicity="daily",
base.currency="USD",  return.class="data.frame", env = .GlobalEnv,
verbose = FALSE, warning = TRUE, auto.assign = FALSE)
class(GSPC_df)
head(GSPC_df)
tail(GSPC_df)
#
# We add a Date column to the data frame *GSPC_df*.
GSPC_df <- add_column(.data=GSPC_df, Date=as.Date(rownames(GSPC_df), format="%Y-%m-%d"), .before="GSPC.Open")
head(GSPC_df)
tail(GSPC_df)
# We set the row names of the data frame *GSPC_df* to the default values.
rownames(GSPC_df) <- NULL
head(GSPC_df)
tail(GSPC_df)
# We add an Index column to the data frame *ESM24.CME_df*.
GSPC_df <- add_column(.data=GSPC_df, Index=1:nrow(GSPC_df), .before="Date")
head(GSPC_df)
tail(GSPC_df)
# We save, remove, and restore the downloaded file
save(GSPC_df, file="GSPC_2022_04_12__2023_04_11_df.RData")
# rm(GSPC_df)
head(GSPC_df)
#
# LOAD
load("GSPC_2022_04_12__2023_04_11_df.RData")
head(GSPC_df)
tail(GSPC_df)
#
# Note that the numbers of rows in data frames *ESM24.CME_df* and *GSPC_df* are different.
# More precisely, the data frame *ESM24.CME_df* contains one more row than *GSPC_df*.
# Hence, there are rows in *ESM24.CME_df* which are not in *GSPC_df*. The converse also being possible.
# To know what row of *ESM24.CME_df* is not in *GSPC_df* we use the following function
ESM24.CME_add_row <- which(!(ESM24.CME_df$Date %in% GSPC_df$Date))
class(ESM24.CME_add_row)
show(ESM24.CME_add_row)
# 192
#
# The *ESM24.CME_add_row* corresponds to the date
show(ESM24.CME_df$Date[ESM24.CME_add_row])
# "2023-01-16"
#
# Since only one row of *ESM24.CME_df* is not in *GSPC_df*, and *ESM24.CME_df* contains only an additional row,
# all rows in *GSPC_df* must be in *ESM24.CME_df*.
# However, if we check the possibility that some rows of *ESM24.CME_df* are not in *ESM24.CME_df*, we find
GSPC_add_row <- which(!(GSPC_df$Date %in% ESM24.CME_df$Date))
show(GSPC_add_row)
# integer(0)
# which confirms that all rows of *GSPC_df* are in *ESM24.CME_df*.
# Hence, we check the data frames ESM24.CME_df and GSPC_df$Date around the the missed row.
show(ESM24.CME_df[(ESM24.CME_add_row-5):(ESM24.CME_add_row+5),])
show(GSPC_df[(ESM24.CME_add_row-5):(ESM24.CME_add_row+5),])
# A quick investigation on the web shows that wall Street was closed on January 16th, 2023
# https://finance.yahoo.com/news/stock-market-news-jan-17-143102176.html?guccounter=1&guce_referrer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8&guce_referrer_sig=AQAAAAOBZFEnSAfCF1b_7ScWnp1uOGaRQ6sa8EpkTXHx-Wnb-ZyYH4JrWg5jC7RsNw1dd2TU3GgzwiAohGABwZxg41ZyLsabaJdPDlmeKCqOAE3f-kCaaeOnIojVO6UebBoUQfq_Ijuwl65ShRaQ5-vWw17JbcspTXH_K0p7mYtU2WdR
# Consider that the future ESM24.CME is traded on CME at Chicago.
# In the end, to homogenize the data frames *ESM24.CME_df* and *GSPC_df*, we delete the *ESM24.CME_add_row* and We
# reset the row names and the Index column of the data frame *ESM24.CME_df* to the default values.
ESM24.CME_df <- ESM24.CME_df[-ESM24.CME_add_row,]
show(ESM24.CME_df[(ESM24.CME_add_row-5):(ESM24.CME_add_row+5),])
rownames(ESM24.CME_df) <- NULL
ESM24.CME_df$Index <- 1:nrow(ESM24.CME_df)
show(ESM24.CME_df[(ESM24.CME_add_row-5):(ESM24.CME_add_row+5),])
nrow(ESM24.CME_df)
# 250
# Now, we add the *GSPC_df$GSPC.Adjusted* column to the data frame *ESM24.CME_df*
Ext_ESM24.CME_df <- add_column(.data=ESM24.CME_df, GSPC.Adjusted=GSPC_df$GSPC.Adjusted, .after="ESM24.CME.Adjusted" )
head(Ext_ESM24.CME_df)
# We add a column *Days.to.Maturity*, which accounts for the number of days from the rows of the column
# *ESM24.CME_df$Date*, to the Future Maturity or Expiration Date *2023-06-16*
Ext_ESM24.CME_df <- add_column(.data=Ext_ESM24.CME_df,
Days.to.Maturity=as.vector(difftime(as.Date(as.character("2023-06-16")), Ext_ESM24.CME_df$Date, units="days")),
.after="GSPC.Adjusted")
head(Ext_ESM24.CME_df)
# We add a column *Days.to.Maturity*, which accounts for the number of days from the rows of the column
# *ESM24.CME_df$Date*, to the Future Maturity or Expiration Date *2023-06-16*
Ext_ESM24.CME_df <- add_column(.data=Ext_ESM24.CME_df,
Days.to.Maturity=as.vector(difftime(as.Date(as.character("2023-06-16")), Ext_ESM24.CME_df$Date, units="days")),
.after="GSPC.Adjusted")
head(Ext_ESM24.CME_df)
tail(Ext_ESM24.CME_df)
# We also add the column *Months.to.Maturity* [resp. *Years.to.Maturity*], which accounts for the number of months
# [resp. years] from the rows of the column *ESM24.CME_df$Date*, to the Future Maturity Date *2023-06-23*.
Ext_ESM24.CME_df <- add_column(.data=Ext_ESM24.CME_df,
Months.to.Maturity=as.vector(Ext_ESM24.CME_df$Days.to.Maturity/30.4369),
Years.to.Maturity=as.vector(Ext_ESM24.CME_df$Days.to.Maturity/365.2425),
.after="Days.to.Maturity")
head(Ext_ESM24.CME_df)
tail(Ext_ESM24.CME_df)
#
# In the end, we add four columns with the estimated r_t_f and percentage r_t_f, from the formula
# r_t_f = K/S_t - 1,
# and the annualized r_t_f_a and percentage r_t_f_a, from the formula
# r_t_f_a = (1+r_t_f)^(365.2425/t)-1.
#
Ext_ESM24.CME_df <- add_column(.data=Ext_ESM24.CME_df,
Ret.Rate.at.Maturity=(Ext_ESM24.CME_df$ESM24.CME.Adjusted/Ext_ESM24.CME_df$GSPC.Adjusted-1),
Perc.Ret.Rate.at.Maturity=label_percent(accuracy = 0.001)(Ext_ESM24.CME_df$ESM24.CME.Adjusted/Ext_ESM24.CME_df$GSPC.Adjusted-1),
Ann.Ret.Rate.at.Maturity=((Ext_ESM24.CME_df$ESM24.CME.Adjusted/Ext_ESM24.CME_df$GSPC.Adjusted)^(365.2425/Ext_ESM24.CME_df$Days.to.Maturity)-1),
Perc.Ann.Ret.Rate.at.Maturity=label_percent(accuracy = 0.001)((Ext_ESM24.CME_df$ESM24.CME.Adjusted/Ext_ESM24.CME_df$GSPC.Adjusted)^(365.2425/Ext_ESM24.CME_df$Days.to.Maturity)-1),
.after="Years.to.Maturity")
head(Ext_ESM24.CME_df)
tail(Ext_ESM24.CME_df)
#
save(Ext_ESM24.CME_df, file="Ext_ESM24.CME_2022_04_12__2023_04_11_df.RData")
# rm(Ext_ESM24.CME_df)
head(Ext_ESM24.CME_df)
#
# LOAD
load("Ext_ESM24.CME_2022_04_12__2023_04_11_df.RData")
# To download data we use the function *getSymbols.yahoo* of the *quantmod* library
# library(quantmod)
ESM24.CME_df <- getSymbols.yahoo("ESM24.CME", from=From, to=To, periodicity="daily",
base.currency="USD",  return.class="data.frame", env = .GlobalEnv,
verbose = FALSE, warning = TRUE, auto.assign = FALSE)
ESM24.CME_df
# Reading libraries ####
library(base)
library(stats)
library(readxl)
library(rlist)
library(tibble)
library(dplyr)
library(tidyverse)
library("data.table")
library(reshape2)
library(ggplot2)
library(scales)
library(numbers)
library(lubridate)
library(zoo)
library(xts)
library(TTR)
library(quantmod)
library(moments)
library(lmtest)
library(strucchange)
library(broom)
library(rlang)
library(gridSVG)
library(grid)
#------------------------------------------------------------------------------#
# Drawing plot -----------------------------------------------------------------
#
# To draw a plot of the Treasury Yield Curve Rates, we need to manipulate the data frame *US_DTR_2020_2023_df*.####
# First, we extract some rows (e.g., from March 31st to April 11th, 2023) from the data frame and rename the rows.
init_date  <- which(US_DTR_2020_2023_df$Date=="2023-03-31")
final_date <- which(US_DTR_2020_2023_df$Date=="2023-04-11")
source("~/Documenti/Obsidian/Personale/Università/Magistrale/Mercati finanziari/Data & Scripts/Rivisti da me/Time Series Examples - Bonds-Options-Futures-04.R", echo=TRUE)
